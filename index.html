<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
    <meta name="google-adsense-account" content="ca-pub-5336954985984577">
    <title>Stellar Defender</title>
    <!-- Inter Font from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;800&display=swap" rel="stylesheet">
    <style>
        /* Base styles for the entire page and game container */
        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrolling */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none; /* For Safari */
            -moz-user-select: none; /* For Firefox */
            -ms-user-select: none; /* For IE/Edge */
            overscroll-behavior-y: contain; /* Prevent pull-to-refresh on mobile */
            background-color: #000; /* Ensure black background */
            color: #fff; /* Default text color */
        }

        #app {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: fixed;
            inset: 0;
            background-color: #000;
        }

        /* HUD Styles */
        #hud {
            flex-shrink: 0;
            background-color: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 16px; /* Default padding for desktop */
            pointer-events: auto; /* Allow interaction */
        }

        #hud-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 960px; /* Equivalent to max-w-6xl */
            margin: 0 auto;
        }

        .hud-info {
            display: flex;
            gap: 8px; /* Equivalent to gap-2 sm:gap-4 */
            align-items: center;
        }

        .hud-box {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            border-radius: 8px; /* rounded-lg */
            padding: 8px 12px; /* px-3 py-2 sm:px-4 */
            color: #fff;
            display: flex;
            align-items: center;
            gap: 4px; /* gap-1 sm:gap-2 */
        }

        .hud-box .label {
            font-size: 0.875rem; /* text-xs sm:text-sm */
            opacity: 0.8;
        }

        .hud-box .value {
            font-size: 1.25rem; /* text-base sm:text-lg for HUD */
            font-weight: bold;
        }
        
        .hud-box.lives-box .heart-icon {
            color: #ef4444; /* text-red-500 */
            fill: currentColor;
            width: 24px; /* Default size for desktop */
            height: 24px;
        }

        .pause-button {
            background-color: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px);
            border-radius: 8px;
            padding: 8px; /* p-2 sm:p-3 */
            color: #fff;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            outline: none; /* Remove default focus outline */
        }

        .pause-button:hover {
            background-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px); /* Slight lift on hover */
        }

        .pause-button:active {
            transform: scale(0.95);
            background-color: rgba(255, 255, 255, 0.4); /* More pronounced press */
        }

        .pause-button .icon {
            width: 20px; /* Default size for desktop */
            height: 20px;
        }

        /* Game Area Styles */
        #game-area {
            flex-grow: 1;
            position: relative;
            min-height: 0;
        }

        #gameCanvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
        }

        /* Overlay Screens Styles */
        .overlay {
            position: absolute;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px); /* backdrop-blur-sm */
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto; /* Allow interaction */
            text-align: center;
            color: #fff;
            z-index: 10; /* Ensure overlays are on top */
        }

        .overlay-content {
            max-width: 448px; /* max-w-md */
            margin: 0 16px; /* mx-4 */
        }

        .game-title {
            font-size: 3rem; /* text-4xl sm:text-5xl md:text-6xl lg:text-7xl */
            font-weight: bold;
            margin-bottom: 8px;
            background-image: linear-gradient(to right, #60a5fa, #9333ea); /* from-blue-400 to-purple-600 */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
        }

        .game-subtitle {
            font-size: 2rem; /* text-2xl sm:text-3xl md:text-4xl lg:text-5xl */
            font-weight: bold;
            margin-bottom: 32px;
            background-image: linear-gradient(to right, #9333ea, #f97316); /* from-purple-600 to-pink-400 */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            gap: 16px; /* space-y-4 */
        }

        .game-button {
            width: 100%;
            font-weight: bold;
            padding: 12px 24px; /* py-3 px-6 text-base */
            border-radius: 8px;
            transition: all 0.2s ease-in-out, box-shadow 0.2s ease-in-out; /* Add box-shadow to transition */
            transform: scale(1);
            cursor: pointer;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2), 0 10px 15px rgba(0, 0, 0, 0.1); /* Stronger initial shadow */
            outline: none; /* Remove default focus outline */
        }

        .game-button:hover {
            transform: translateY(-2px) scale(1.02); /* Lift and slight scale */
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3), 0 12px 20px rgba(0, 0, 0, 0.15); /* Even stronger shadow on hover */
        }

        .game-button:active {
            transform: scale(0.95); /* More pronounced press effect */
            box-shadow: 0 2px 3px rgba(0, 0, 0, 0.2), 0 4px 6px rgba(0, 0, 0, 0.1); /* Subtle shadow on press */
        }

        .start-button {
            background-image: linear-gradient(to right, #2563eb, #9333ea); /* from-blue-600 to-purple-600 */
            color: #fff;
        }

        .start-button:hover {
            background-image: linear-gradient(to right, #1d4ed8, #7e22ce); /* hover:from-blue-700 hover:to-purple-700 */
        }

        .exit-button, .main-menu-button {
            background-image: linear-gradient(to right, #4b5563, #374151); /* from-gray-600 to-gray-700 */
            color: #fff;
        }

        .exit-button:hover, .main-menu-button:hover {
            background-image: linear-gradient(to right, #374151, #1f2937); /* hover:from-gray-700 hover:to-gray-800 */
        }

        .restart-button {
            background-image: linear-gradient(to right, #ea580c, #dc2626); /* from-orange-600 to-red-600 */
            color: #fff;
        }

        .restart-button:hover {
            background-image: linear-gradient(to right, #c2410c, #b91c1c); /* hover:from-orange-700 hover:to-red-700 */
        }

        .resume-button {
            background-image: linear-gradient(to right, #16a34a, #2563eb); /* from-green-600 to-blue-600 */
            color: #fff;
        }

        .resume-button:hover {
            background-image: linear-gradient(to right, #15803d, #1d4ed8); /* hover:from-green-700 hover:to-blue-700 */
        }


        .score-display {
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 16px;
            margin-top: 16px;
            color: #60a5fa; /* text-blue-400 */
        }

        .score-display .score-text {
            font-size: 1rem; /* text-sm mobile, text-base desktop */
        }

        .score-display .high-score-value {
            font-weight: bold;
        }

        /* Game Over Specific Styles */
        #gameover-screen .game-subtitle {
            margin-bottom: 16px; /* mb-4 */
            color: #f87171; /* text-red-400 */
            background: none;
            -webkit-text-fill-color: unset;
        }
        
        #gameover-screen .final-score-box {
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 24px; /* p-6 */
            margin-bottom: 24px; /* mb-6 */
        }
        
        #gameover-screen .final-score-label {
            font-size: 1.25rem; /* text-xl mobile, text-2xl desktop */
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        #gameover-screen .final-score-value {
            font-size: 2rem; /* responsive.subtitle */
            font-weight: bold;
            color: #fbbf24; /* text-yellow-400 */
            margin-bottom: 16px; /* mb-4 */
        }
        
        #gameover-screen .new-high-score {
            color: #4ade80; /* text-green-400 */
            font-weight: bold;
            margin-bottom: 8px; /* mb-2 */
            font-size: 1rem; /* text-sm mobile, text-base desktop */
        }

        /* Touch Controls Styles (Only for touch devices) */
        #touch-controls {
            flex-shrink: 0;
            background-color: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: 16px; /* Default padding for desktop */
            pointer-events: auto;
            display: none; /* Hidden by default, shown via JS */
        }

        #touch-controls-content {
            max-width: 448px; /* max-w-md */
            margin: 0 auto;
        }

        .control-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr; /* 3 columns for D-pad layout */
            grid-template-rows: 1fr 1fr 1fr; /* 3 rows for D-pad layout */
            width: 288px; /* Default size for desktop */
            height: 288px;
            gap: 8px; /* gap-2 sm:gap-3 */
            margin: 0 auto; /* Center the grid */
        }

        /* Explicit positioning for D-pad buttons */
        #control-up { grid-column: 2; grid-row: 1; }
        #control-left { grid-column: 1; grid-row: 2; }
        #control-right { grid-column: 3; grid-row: 2; }
        #control-down { grid-column: 2; grid-row: 3; }
        
        .control-button {
            background-color: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px);
            border-radius: 12px; /* rounded-xl */
            color: #fff;
            font-weight: bold;
            transition: all 0.1s ease-in-out, box-shadow 0.1s ease-in-out; /* Added box-shadow to transition */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 10px 15px rgba(0, 0, 0, 0.05); /* initial shadow */
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight */
            outline: none; /* Remove default focus outline */
            position: relative; /* For icon scaling */
        }

        .control-button:hover {
            background-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2), 0 12px 20px rgba(0, 0, 0, 0.1); /* Stronger shadow on hover */
        }

        .control-button:active {
            background-color: rgba(255, 255, 255, 0.4);
            transform: scale(0.92); /* More pronounced press effect */
            box-shadow: 0 2px 3px rgba(0, 0, 0, 0.2), inset 0 0 5px rgba(255, 255, 255, 0.5); /* Inset shadow for pressed look */
            border-color: rgba(255, 255, 255, 0.5); /* Brighter border on active */
        }

        .control-empty-placeholder {
            display: none; /* Hide placeholder cells for the D-pad layout */
        }

        .control-empty-center {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            grid-column: 2; /* Explicitly place in the center */
            grid-row: 2;
        }

        .control-button .icon {
            width: 48px; /* Default size for desktop */
            height: 48px;
            transition: transform 0.1s ease-out; /* Icon scaling transition */
        }
        .control-button:hover .icon {
            transform: scale(1.1); /* Icon slightly larger on hover */
        }
        .control-button:active .icon {
            transform: scale(0.9); /* Icon slightly smaller on active */
        }

        /* Responsive Styles (Mobile) */
        @media (max-width: 767px) {
            #hud { padding: 12px 16px; /* p-3 sm:p-4 */ }
            .hud-info { gap: 8px; }
            .hud-box { padding: 8px 12px; }
            .hud-box .label { font-size: 0.75rem; }
            .hud-box .value { font-size: 1rem; }
            .hud-box.lives-box .heart-icon { width: 20px; height: 20px; }
            .pause-button { padding: 8px; }
            .pause-button .icon { width: 16px; height: 16px; }

            .game-title { font-size: 2.5rem; } /* text-4xl */
            .game-subtitle { font-size: 1.5rem; } /* text-2xl */
            .game-button { padding: 12px 24px; font-size: 1rem; } /* py-3 px-6 text-base */
            .score-display { padding: 12px; }
            .score-display .score-text { font-size: 0.875rem; }
            #gameover-screen .final-score-label { font-size: 1.125rem; } /* text-xl */
            #gameover-screen .final-score-value { font-size: 1.5rem; } /* responsive.subtitle for mobile */
            #gameover-screen .new-high-score { font-size: 0.875rem; } /* text-sm */

            #touch-controls { padding-bottom: calc(32px + env(safe-area-inset-bottom)); } /* pb-safe pb-8 */
            .control-grid { width: 192px; height: 192px; gap: 8px; } /* w-48 h-48 */
            .control-button .icon { width: 32px; height: 32px; }
        }

        /* Responsive Styles (Tablet) */
        @media (min-width: 768px) and (max-width: 1023px) {
            #hud { padding: 16px 24px; /* p-4 md:p-6 */ }
            .hud-info { gap: 16px; }
            .hud-box { padding: 12px 16px; }
            .hud-box .label { font-size: 0.875rem; }
            .hud-box .value { font-size: 1.125rem; } /* text-lg */
            .hud-box.lives-box .heart-icon { width: 24px; height: 24px; }
            .pause-button { padding: 12px; }
            .pause-button .icon { width: 20px; height: 20px; }

            .game-title { font-size: 3rem; } /* text-5xl md:text-6xl */
            .game-subtitle { font-size: 2rem; } /* text-3xl md:text-4xl */
            .game-button { padding: 16px 32px; font-size: 1.125rem; } /* py-4 px-8 text-lg */
            .score-display { padding: 16px; }
            .score-display .score-text { font-size: 1rem; }
            #gameover-screen .final-score-label { font-size: 1.25rem; } /* text-xl */
            #gameover-screen .final-score-value { font-size: 2rem; } /* responsive.subtitle for tablet */
            #gameover-screen .new-high-score { font-size: 1rem; } /* text-base */

            #touch-controls { padding-bottom: calc(48px + env(safe-area-inset-bottom)); } /* pb-12 */
            .control-grid { width: 256px; height: 256px; gap: 12px; } /* w-64 h-64 */
            .control-button .icon { width: 40px; height: 40px; }
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Top HUD Bar - Outside Game Area -->
        <div id="hud" style="display: none;">
            <div id="hud-content">
                <div class="hud-info">
                    <div class="hud-box">
                        <div class="label">Score</div>
                        <div id="score-display" class="value">0</div>
                    </div>
                    <div class="hud-box lives-box">
                        <span id="lives-display">
                            <!-- Heart icons will be dynamically inserted here -->
                        </span>
                    </div>
                </div>
                <button id="pause-button" class="pause-button">
                    <svg class="icon" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path strokeLinecap="round" strokeLinejoin="round" d="M8 6v12M16 6v12"></path>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Game Area -->
        <div id="game-area">
            <canvas id="gameCanvas"></canvas>
            
            <!-- Overlay Screens -->
            <div id="overlay-screens">
                <!-- Menu Screen -->
                <div id="menu-screen" class="overlay">
                    <div class="overlay-content">
                        <h1 class="game-title">STELLAR</h1>
                        <h2 class="game-subtitle">DEFENDER</h2>
                        <div class="button-group">
                            <button id="start-game-button" class="game-button start-button">
                                START GAME
                            </button>
                            <a href="https://games.gamebin.online/">
                          <button id="exit-button" class="game-button exit-button">
                                <svg class="icon" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="width:20px;height:20px;">
                                    <path strokeLinecap="round" strokeLinejoin="round" d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4m7 14 5-5-5-5m5 5H9"></path>
                                </svg>
                                EXIT
                            </button>
                            </a>
                            <div class="score-display">
                                <div class="score-text">High Score: <span id="high-score-display" class="high-score-value">0</span></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Pause Screen -->
                <div id="paused-screen" class="overlay" style="display: none;">
                    <div class="overlay-content" style="width: 256px;"> <!-- w-64 -->
                        <h2 class="game-subtitle">PAUSED</h2>
                        <div class="button-group">
                            <button id="resume-game-button" class="game-button resume-button">
                                <svg class="icon" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="width:20px;height:20px;">
                                    <path strokeLinecap="round" strokeLinejoin="round" d="M5 3L19 12L5 21V3Z"></path>
                                </svg>
                                Resume Game
                            </button>
                            <button id="restart-game-button" class="game-button restart-button">
                                <svg class="icon" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="width:20px;height:20px;">
                                    <path strokeLinecap="round" strokeLinejoin="round" d="M21 12a9 9 0 1 1-9-9c2.5 0 4.9 1 6.7 2.8L22 8M22 3v5h-5"></path>
                                    </svg>
                                Restart Game
                            </button>
                            <button id="main-menu-button-from-pause" class="game-button main-menu-button">
                                <svg class="icon" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="width:20px;height:20px;">
                                    <path strokeLinecap="round" strokeLinejoin="round" d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><path strokeLinecap="round" strokeLinejoin="round" d="M9 22V12h6v10"></path>
                                </svg>
                                Main Menu
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Game Over Screen -->
                <div id="gameover-screen" class="overlay" style="display: none;">
                    <div class="overlay-content">
                        <h2 class="game-subtitle">GAME OVER</h2>
                        <div class="final-score-box">
                            <div class="final-score-label">Final Score</div>
                            <div id="final-score-display" class="final-score-value">0</div>
                            <div id="new-high-score-message" class="new-high-score" style="display: none;">ðŸŽ‰ NEW HIGH SCORE! ðŸŽ‰</div>
                        </div>
                        <div class="button-group">
                            <button id="play-again-button" class="game-button start-button">
                                PLAY AGAIN
                            </button>
                            <button id="main-menu-button-from-gameover" class="game-button main-menu-button">
                                MAIN MENU
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Bottom Controls Panel (Touch Devices Only) - Outside Game Area -->
        <div id="touch-controls">
            <div id="touch-controls-content">
                <div class="control-grid">
                    <div class="control-empty-placeholder"></div>
                    <button id="control-up" class="control-button arrow-button">
                        <svg class="icon" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path strokeLinecap="round" strokeLinejoin="round" d="M12 19V5M5 12l7-7 7 7"></path>
                        </svg>
                    </button>
                    <div class="control-empty-placeholder"></div>

                    <button id="control-left" class="control-button arrow-button">
                        <svg class="icon" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path strokeLinecap="round" strokeLinejoin="round" d="M19 12H5M12 5l-7 7 7 7"></path>
                        </svg>
                    </button>
                    <div class="control-empty-center"></div> <!-- This is the middle empty one -->
                    <button id="control-right" class="control-button arrow-button">
                        <svg class="icon" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path strokeLinecap="round" strokeLinejoin="round" d="M5 12h14M12 5l7 7-7 7"></path>
                        </svg>
                    </button>

                    <div class="control-empty-placeholder"></div>
                    <button id="control-down" class="control-button arrow-button">
                        <svg class="icon" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path strokeLinecap="round" strokeLinejoin="round" d="M12 5v14M19 12l-7 7-7-7"></path>
                        </svg>
                    </button>
                    <div class="control-empty-placeholder"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global game state variables
        let gameState = 'menu'; // menu, playing, paused, gameOver
        let score = 0;
        let lives = 3;
        let highScore = 0;
        let isTouchDevice = false;
        let deviceType = 'desktop'; // mobile, tablet, desktop

        // DOM elements
        const hudElement = document.getElementById('hud');
        const scoreDisplayElement = document.getElementById('score-display');
        const livesDisplayElement = document.getElementById('lives-display');
        const pauseButton = document.getElementById('pause-button');
        
        const menuScreen = document.getElementById('menu-screen');
        const startGameButton = document.getElementById('start-game-button');
        const exitButton = document.getElementById('exit-button');
        const highScoreDisplay = document.getElementById('high-score-display');

        const pausedScreen = document.getElementById('paused-screen');
        const resumeGameButton = document.getElementById('resume-game-button');
        const restartGameButton = document.getElementById('restart-game-button');
        const mainMenuButtonFromPause = document.getElementById('main-menu-button-from-pause');

        const gameOverScreen = document.getElementById('gameover-screen');
        const finalScoreDisplay = document.getElementById('final-score-display');
        const newHighScoreMessage = document.getElementById('new-high-score-message');
        const playAgainButton = document.getElementById('play-again-button');
        const mainMenuButtonFromGameOver = document.getElementById('main-menu-button-from-gameover');

        const touchControls = document.getElementById('touch-controls');
        const controlUp = document.getElementById('control-up');
        const controlDown = document.getElementById('control-down');
        const controlLeft = document.getElementById('control-left');
        const controlRight = document.getElementById('control-right');


        let gameInstance; // Instance of StellarDefenderGame

        // Audio Context
        let audioContext = null;

        /**
         * Initializes the audio context for sound playback.
         */
        function initializeAudio() {
            if (typeof window !== 'undefined' && (window.AudioContext || window.webkitAudioContext)) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        /**
         * Plays a sound effect based on its type.
         * Only 'shoot' sound is implemented.
         * @param {string} type - The type of sound to play (e.g., 'shoot').
         */
        function playSound(type) {
            if (type !== 'shoot') return; // Only play shooting sound

            if (audioContext) {
                try {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    // Shooting sound parameters
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                } catch (e) {
                    console.error("Could not play sound", e);
                }
            }

            // Vibration feedback on touch devices for shooting only
            if (isTouchDevice && navigator.vibrate) {
                navigator.vibrate(30);
            }
        }

        /**
         * Checks the device type (mobile, tablet, desktop) based on screen width and touch capability.
         * Updates global `deviceType` and `isTouchDevice` variables.
         */
        function checkDevice() {
            const width = window.innerWidth;
            const isTouchCapable = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            
            if (isTouchCapable && width < 768) {
                deviceType = 'mobile';
                isTouchDevice = true;
            } else if (isTouchCapable && width >= 768 && width < 1024) {
                deviceType = 'tablet';
                isTouchDevice = true;
            } else {
                deviceType = 'desktop';
                isTouchDevice = false;
            }

            updateUILayout(); 
        }

        /**
         * Updates the visibility of UI elements based on the current game state.
         */
        function updateUIVisibility() {
            hudElement.style.display = gameState === 'playing' ? 'flex' : 'none';
            menuScreen.style.display = gameState === 'menu' ? 'flex' : 'none';
            pausedScreen.style.display = gameState === 'paused' ? 'flex' : 'none';
            gameOverScreen.style.display = gameState === 'gameOver' ? 'flex' : 'none';
            touchControls.style.display = (isTouchDevice && gameState === 'playing') ? 'block' : 'none';
        }

        /**
         * Updates the game score displayed in the HUD.
         * @param {number} newScore - The current score.
         */
        function updateScore(newScore) {
            score = newScore;
            scoreDisplayElement.textContent = score.toLocaleString();
        }

        /**
         * Updates the lives count displayed in the HUD with heart icons.
         * @param {number} newLives - The current number of lives.
         */
        function updateLives(newLives) {
            lives = newLives;
            livesDisplayElement.innerHTML = ''; // Clear existing hearts
            const heartSVG = `
                <svg class="heart-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                </svg>
            `;
            // Adjust heart icon size based on device type
            const iconWidth = deviceType === 'mobile' ? 20 : 24;
            const iconHeight = deviceType === 'mobile' ? 20 : 24;
            for (let i = 0; i < lives; i++) {
                livesDisplayElement.insertAdjacentHTML('beforeend', heartSVG.replace(/width="24"|height="24"/g, `width="${iconWidth}" height="${iconHeight}"`));
            }
        }

        /**
         * Handles the game over state transition.
         */
        function onGameOver() {
            setGameState('gameOver');
        }

        /**
         * Saves game data (high score) to local storage.
         */
        function saveGame() {
            const currentHighScore = Math.max(score, highScore);
            localStorage.setItem('stellarDefenderData', JSON.stringify({ highScore: currentHighScore }));
            if (currentHighScore > highScore) {
                highScore = currentHighScore;
                highScoreDisplay.textContent = highScore.toLocaleString();
                newHighScoreMessage.style.display = 'block';
            } else {
                newHighScoreMessage.style.display = 'none';
            }
        }

        /**
         * Sets the current game state and updates UI visibility.
         * @param {string} newState - The new game state.
         */
        function setGameState(newState) {
            if ((gameState === 'gameOver' || gameState === 'menu') && (newState === 'playing' || newState === 'menu')) {
                saveGame(); // Save score before starting new game or returning to menu
            }
            gameState = newState;
            updateUIVisibility();

            if (newState === 'gameOver') {
                finalScoreDisplay.textContent = score.toLocaleString();
            }
        }

        /**
         * Starts the game.
         */
        function startGame() {
            setGameState('playing');
            updateScore(0);
            updateLives(3);
            gameInstance.start();
        }

        /**
         * Pauses the game.
         */
        function pauseGame() {
            setGameState('paused');
            gameInstance.pause();
        }

        /**
         * Resumes the game.
         */
        function resumeGame() {
            setGameState('playing');
            gameInstance.resume();
        }

        /**
         * Restarts the game from the current wave.
         */
        function restartGame() {
            setGameState('playing');
            updateScore(0);
            updateLives(3);
            gameInstance.start(); // Resets game internally
        }

        /**
         * Returns to the main menu.
         */
        function returnToMenu() {
            setGameState('menu');
            gameInstance.stop(); // Stops game loop
        }

        /**
         * Handles exiting the game (navigates to an external URL).
         */
        function handleExit() {
            window.location.href = 'https://games.gamebin.online';
        }

        /**
         * Applies responsive layout adjustments based on device type.
         * Also informs the game instance to recalculate its boundaries.
         */
        function updateUILayout() {
            if (gameInstance) {
                gameInstance.deviceType = deviceType; // Update game engine's device type
                gameInstance.resize(); // Trigger re-calculation of game boundaries
            }
        }

        // --- Event Listeners Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                console.error("Canvas element not found!");
                return;
            }

            // Correctly lock the viewport without breaking buttons
            const preventDefaultTouchMove = (e) => {
                // Prevent scrolling *unless* the target is an interactive button within touch controls
                if (e.target === canvas || (touchControls.contains(e.target) && !e.target.classList.contains('control-button'))) {
                    e.preventDefault();
                }
            };
            document.body.style.overflow = 'hidden'; // Prevents entire page scroll
            document.addEventListener('touchmove', preventDefaultTouchMove, { passive: false });
            
            // Initial device check and setup
            checkDevice();

            // Load saved data
            const savedData = localStorage.getItem('stellarDefenderData');
            if (savedData) {
                const data = JSON.parse(savedData);
                highScore = data.highScore || 0;
                highScoreDisplay.textContent = highScore.toLocaleString();
            }

            initializeAudio();

            gameInstance = new StellarDefenderGame(canvas, {
                onScoreUpdate: updateScore,
                onLivesUpdate: updateLives,
                onGameOver: onGameOver,
                playSound: playSound,
                deviceType: deviceType // Pass initial deviceType
            });

            // Initial resize for canvas
            gameInstance.resize();

            // Setup UI event listeners
            startGameButton.addEventListener('click', startGame);
            exitButton.addEventListener('click', handleExit);
            pauseButton.addEventListener('click', pauseGame);
            resumeGameButton.addEventListener('click', resumeGame);
            restartGameButton.addEventListener('click', restartGame);
            mainMenuButtonFromPause.addEventListener('click', returnToMenu);
            playAgainButton.addEventListener('click', startGame);
            mainMenuButtonFromGameOver.addEventListener('click', returnToMenu);

            // Touch control listeners (using mousedown/mouseup for unified input, but touch specific events for player movement flags)
            controlUp.addEventListener('touchstart', (e) => { e.preventDefault(); gameInstance.setPlayerMovement('up', true); }, { passive: false });
            controlUp.addEventListener('touchend', (e) => { e.preventDefault(); gameInstance.setPlayerMovement('up', false); }, { passive: false });
            controlDown.addEventListener('touchstart', (e) => { e.preventDefault(); gameInstance.setPlayerMovement('down', true); }, { passive: false });
            controlDown.addEventListener('touchend', (e) => { e.preventDefault(); gameInstance.setPlayerMovement('down', false); }, { passive: false });
            controlLeft.addEventListener('touchstart', (e) => { e.preventDefault(); gameInstance.setPlayerMovement('left', true); }, { passive: false });
            controlLeft.addEventListener('touchend', (e) => { e.preventDefault(); gameInstance.setPlayerMovement('left', false); }, { passive: false });
            controlRight.addEventListener('touchstart', (e) => { e.preventDefault(); gameInstance.setPlayerMovement('right', true); }, { passive: false });
            controlRight.addEventListener('touchend', (e) => { e.preventDefault(); gameInstance.setPlayerMovement('right', false); }, { passive: false });
            
            // Global resize listener
            window.addEventListener('resize', () => {
                checkDevice(); // Re-check device type
                gameInstance.resize(); // Inform game engine about resize
            });

            // Set initial UI visibility
            updateUIVisibility();
        });


        // Game Engine Classes (Copied directly from React code as they are pure JS classes)
        class StellarDefenderGame {
            constructor(canvas, callbacks) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.callbacks = callbacks;
                this.isRunning = false;
                this.isPaused = false;
                this.deviceType = callbacks.deviceType || 'desktop'; // Get device type from callbacks
                
                this.player = new Player(0, 0);
                this.enemies = [];
                this.projectiles = [];
                this.particles = [];
                this.powerUps = [];
                this.stars = [];
                this.scoreTexts = [];
                
                this.wave = 1;
                this.score = 0;
                this.lives = 3;
                this.enemySpawnTimer = 0;
                this.waveTimer = 0;
                
                this.keys = {};
                this.mousePos = { x: 0, y: 0 };
                this.isTouching = false;
                
                this.playerMovement = { up: false, down: false, left: false, right: false };
                this.playSound = callbacks.playSound || (() => {});

                // Calculate safe play area boundaries based on device type
                this.getDeviceBoundaries();

                this.initializeBackground();
                this.setupEventListeners();
                
                this.lastTime = 0;
                this.gameLoop = this.gameLoop.bind(this);
            }

            getDeviceBoundaries() {
                // Store original display properties to restore them later
                const originalHudDisplay = hudElement.style.display;
                const originalTouchControlsDisplay = touchControls.style.display;

                // Make elements visible temporarily to get their computed height
                hudElement.style.display = 'flex'; // Ensure it's flex for correct layout
                if (isTouchDevice) { // Only set touch controls visible if on touch device
                    touchControls.style.display = 'block';
                }

                this.topHUDHeight = hudElement.offsetHeight;
                // Further reduced bottomControlsHeight to expand play area
                this.bottomControlsHeight = isTouchDevice ? (deviceType === 'mobile' ? 80 : 180) : 0; // Keeping this the same as previous.
                
                // Restore original display properties
                hudElement.style.display = originalHudDisplay;
                touchControls.style.display = originalTouchControlsDisplay;

                // Optional: Console log to verify values
                // console.log(`Device: ${this.deviceType}, HUD Height: ${this.topHUDHeight}, Controls Height: ${this.bottomControlsHeight}`);
            }

            setPlayerMovement(direction, isPressed) {
                if (this.playerMovement.hasOwnProperty(direction)) {
                    this.playerMovement[direction] = isPressed;
                }
            }

            initializeBackground() {
                this.stars = [];
                // Adjust star count based on device performance
                const starCount = this.deviceType === 'mobile' ? 50 : this.deviceType === 'tablet' ? 100 : 200;
                for (let i = 0; i < starCount; i++) {
                    this.stars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: Math.random() * 2 + 0.5,
                        speed: Math.random() * 1.5 + 0.2,
                        opacity: Math.random() * 0.8 + 0.2
                    });
                }
            }

            setupEventListeners() {
                const getMouseCanvasPos = (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    return {
                        x: (e.clientX - rect.left) * (this.canvas.width / rect.width),
                        y: (e.clientY - rect.top) * (this.canvas.height / rect.height)
                    };
                };

                // Only handle mouse input for player movement if not a touch device
                window.addEventListener('mousedown', (e) => {
                    if (!isTouchDevice && e.target === this.canvas) {
                        this.isTouching = true;
                        this.mousePos = getMouseCanvasPos(e);
                    }
                });

                window.addEventListener('mousemove', (e) => {
                    if (this.isTouching && !isTouchDevice && e.target === this.canvas) {
                        this.mousePos = getMouseCanvasPos(e);
                    }
                });

                window.addEventListener('mouseup', () => { 
                    if (!isTouchDevice) {
                        this.isTouching = false; 
                    }
                });

                // Keyboard listeners for player movement (always active for desktop fallback)
                window.addEventListener('keydown', (e) => { this.keys[e.key.toLowerCase()] = true; });
                window.addEventListener('keyup', (e) => { this.keys[e.key.toLowerCase()] = false; });
            }

            resize() {
                const container = this.canvas.parentElement;
                if (!container) return;
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = container.clientWidth * dpr;
                this.canvas.height = container.clientHeight * dpr;
                this.ctx.scale(dpr, dpr);
                this.canvas.style.width = `${container.clientWidth}px`;
                this.canvas.style.height = `${container.clientHeight}px`;
                this.getDeviceBoundaries(); // Re-calculate boundaries on resize using actual element heights
                this.initializeBackground(); // Re-initialize background based on new dimensions/device type
                
                // Re-position player if outside new safe area (e.g., after orientation change)
                const canvasWidth = this.canvas.width / window.devicePixelRatio;
                const canvasHeight = this.canvas.height / window.devicePixelRatio;
                const playAreaTop = this.topHUDHeight;
                const playAreaBottom = canvasHeight - this.bottomControlsHeight;
                this.player.x = Math.max(this.player.radius, Math.min(this.player.x, canvasWidth - this.player.radius));
                this.player.y = Math.max(playAreaTop + this.player.radius, Math.min(this.player.y, playAreaBottom - this.player.radius));
            }

            start() {
                this.isRunning = true;
                this.isPaused = false;
                this.score = 0;
                this.wave = 1;
                this.lives = 3;
                this.enemies = [];
                this.projectiles = [];
                this.particles = [];
                this.powerUps = [];
                this.scoreTexts = [];
                
                // Spawn player in the initial safe area
                const canvasWidth = this.canvas.width / window.devicePixelRatio;
                const canvasHeight = this.canvas.height / window.devicePixelRatio;
                const playAreaBottom = canvasHeight - this.bottomControlsHeight;
                this.player.spawn(canvasWidth / 2, playAreaBottom - 100);

                this.callbacks.onLivesUpdate(this.lives);
                this.lastTime = performance.now();
                requestAnimationFrame(this.gameLoop);
            }

            pause() { 
                this.isPaused = true; 
            }

            resume() {
                this.isPaused = false;
                this.lastTime = performance.now();
                requestAnimationFrame(this.gameLoop);
            }

            stop() { 
                this.isRunning = false;
                this.isPaused = true;
            }
            destroy() { this.stop(); }

            addScoreText(x, y, points) {
                this.scoreTexts.push({
                    x: x,
                    y: y,
                    text: `+${points}`,
                    life: 1.0,
                    decay: 0.02
                });
            }

            gameLoop(currentTime) {
                if (!this.isRunning || this.isPaused) return;

                let deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                // Cap deltaTime for stability, especially on mobile
                if (isNaN(deltaTime) || deltaTime > 50) deltaTime = 16.67;

                this.update(deltaTime);
                this.render();

                requestAnimationFrame(this.gameLoop);
            }

            update(deltaTime) {
                const canvasWidth = this.canvas.width / window.devicePixelRatio;
                const canvasHeight = this.canvas.height / window.devicePixelRatio;

                // Calculate safe play area
                const playAreaTop = this.topHUDHeight;
                const playAreaBottom = canvasHeight - this.bottomControlsHeight;

                // Handle player movement
                let dx = 0, dy = 0;
                // Keyboard input (always active)
                if (this.keys['arrowleft'] || this.keys['a']) dx = -1;
                if (this.keys['arrowright'] || this.keys['d']) dx = 1;
                if (this.keys['arrowup'] || this.keys['w']) dy = -1;
                if (this.keys['arrowdown'] || this.keys['s']) dy = 1;
                
                // Touch/Mouse input
                if (isTouchDevice) { // Touch controls from buttons
                    if (this.playerMovement.left) dx = -1;
                    if (this.playerMovement.right) dx = 1;
                    if (this.playerMovement.up) dy = -1;
                    if (this.playerMovement.down) dy = 1;
                } else if (this.isTouching) { // Mouse movement for desktop
                    const constrainedMousePos = {
                        x: Math.max(this.player.radius, Math.min(this.mousePos.x, canvasWidth - this.player.radius)),
                        y: Math.max(playAreaTop + this.player.radius, Math.min(this.mousePos.y, playAreaBottom - this.player.radius))
                    };
                    this.player.moveTowards(constrainedMousePos.x, constrainedMousePos.y, deltaTime);
                }
                
                // Apply keyboard/button movement if not using mouse-to-move
                if (!this.isTouching || isTouchDevice) { // If not desktop mouse-touching, or if it's a touch device
                     if (dx !== 0 || dy !== 0) {
                        this.player.move(dx, dy, deltaTime);
                    }
                }
               
                this.player.update(deltaTime, canvasWidth, playAreaTop, playAreaBottom);

                if (this.player.canFire()) {
                    this.projectiles.push(...this.player.fire());
                    this.playSound('shoot');
                }

                this.projectiles = this.projectiles.filter(p => p.update(deltaTime) && p.y > -50 && p.y < canvasHeight + 50);

                this.enemies.forEach(e => {
                    e.update(deltaTime);
                    // Increased the probability of enemy firing from 0.02 to 0.05
                    if (e.canFire() && Math.random() < 0.05) this.projectiles.push(...e.fire());
                });
                this.enemies = this.enemies.filter(e => e.y < canvasHeight + 50 && e.health > 0);

                this.particles = this.particles.filter(p => p.update(deltaTime) && p.life > 0);
                this.powerUps = this.powerUps.filter(p => p.update(deltaTime) && p.y < canvasHeight + 50);

                this.scoreTexts.forEach(st => {
                    st.life -= st.decay;
                    st.y -= 30 * deltaTime / 1000;
                });
                this.scoreTexts = this.scoreTexts.filter(st => st.life > 0);

                this.stars.forEach(s => {
                    s.y += s.speed;
                    if (s.y > canvasHeight) { s.y = -5; s.x = Math.random() * canvasWidth; }
                });

                this.checkCollisions();
                this.spawnEnemies(deltaTime);
                this.updateWave(deltaTime);

                this.callbacks.onScoreUpdate(this.score);
            }

            playerDied() {
                this.lives--;
                this.callbacks.onLivesUpdate(this.lives);
                this.createExplosion(this.player.x, this.player.y, 'large');
                
                if (this.lives > 0) {
                    const canvasWidth = this.canvas.width / window.devicePixelRatio;
                    const canvasHeight = this.canvas.height / window.devicePixelRatio;
                    const playAreaBottom = canvasHeight - this.bottomControlsHeight;
                    this.player.spawn(canvasWidth / 2, playAreaBottom - 100);

                } else {
                    this.gameOver();
                }
            }

            checkCollisions() {
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const p = this.projectiles[i];
                    if (!p) continue;
                    if (p.isPlayerProjectile) {
                        for (let j = this.enemies.length - 1; j >= 0; j--) {
                            const e = this.enemies[j];
                            if (!e) continue;
                            if (this.checkCollision(p, e)) {
                                e.health -= p.damage;
                                this.createExplosion(p.x, p.y, 'small');
                                if(i < this.projectiles.length) this.projectiles.splice(i, 1);
                                if (e.health <= 0) {
                                    this.createExplosion(e.x, e.y, 'large');
                                    this.score += 3;
                                    this.addScoreText(e.x, e.y, 3);
                                    if (Math.random() < 0.15) this.powerUps.push(new PowerUp(e.x, e.y));
                                    if(j < this.enemies.length) this.enemies.splice(j, 1);
                                }
                                break;
                            }
                        }
                    } else { // Enemy projectile
                        if (this.checkCollision(p, this.player)) {
                            if (this.player.takeDamage(p.damage)) this.playerDied();
                            this.createExplosion(p.x, p.y, 'small');
                            if(i < this.projectiles.length) this.projectiles.splice(i, 1);
                        }
                    }
                }

                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const e = this.enemies[i];
                    if (!e) continue;
                    if (this.checkCollision(this.player, e)) {
                        if (this.player.takeDamage(e.damage)) this.playerDied();
                        this.createExplosion(e.x, e.y, 'large');
                        if(i < this.enemies.length) this.enemies.splice(i, 1);
                    }
                }

                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    const pu = this.powerUps[i];
                    if (!pu) continue;
                    if (this.checkCollision(this.player, pu)) {
                        this.player.applyPowerUp(pu.type);
                        if(i < this.powerUps.length) this.powerUps.splice(i, 1);
                    }
                }
            }

            checkCollision(obj1, obj2) {
                const dx = obj1.x - obj2.x;
                const dy = obj1.y - obj2.y;
                return (dx * dx + dy * dy) < (obj1.radius + obj2.radius) * (obj1.radius + obj2.radius);
            }

            createExplosion(x, y, size) {
                // Adjust particle count based on device performance
                const pCount = size === 'large' ? 
                    (this.deviceType === 'mobile' ? 10 : this.deviceType === 'tablet' ? 15 : 25) : 
                    (this.deviceType === 'mobile' ? 3 : this.deviceType === 'tablet' ? 5 : 10);
                
                const colors = ['#ff6b35', '#f7931e', '#ffd700', '#ff4757'];
                for (let i = 0; i < pCount; i++) {
                    this.particles.push(new Particle(x, y, colors[Math.floor(Math.random() * colors.length)]));
                }
            }

            spawnEnemies(deltaTime) {
                const canvasWidth = this.canvas.width / window.devicePixelRatio;
                this.enemySpawnTimer += deltaTime;
                const spawnRate = Math.max(1200 - this.wave * 50, 400);
                if (this.enemySpawnTimer > spawnRate) {
                    this.enemySpawnTimer = 0;
                    const r = Math.random();
                    const randomX = Math.random() * canvasWidth;
                    if (this.wave > 3 && r > 0.95) this.enemies.push(new Boss(randomX, -100));
                    else if (r > 0.5) this.enemies.push(new AlienShip(randomX, -50));
                    else this.enemies.push(new Meteor(randomX, -50));
                }
            }

            updateWave(deltaTime) {
                this.waveTimer += deltaTime;
                if (this.waveTimer > 30000) { this.wave++; this.waveTimer = 0; }
            }

            gameOver() {
                this.isRunning = false;
                this.callbacks.onGameOver();
            }

            render() {
                const canvasWidth = this.canvas.width / window.devicePixelRatio;
                const canvasHeight = this.canvas.height / window.devicePixelRatio;
                
                this.ctx.fillStyle = '#000014';
                this.ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                this.stars.forEach(star => {
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                    this.ctx.beginPath();
                    this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                this.particles.forEach(p => p.render(this.ctx));
                this.powerUps.forEach(p => p.render(this.ctx));
                this.enemies.forEach(e => e.render(this.ctx));
                this.projectiles.forEach(p => p.render(this.ctx));
                
                if (this.player.health > 0) {
                    this.player.render(this.ctx);
                }
                
                this.ctx.save();
                this.ctx.globalAlpha = 1;
                this.scoreTexts.forEach(st => {
                    this.ctx.globalAlpha = st.life;
                    this.ctx.fillStyle = `rgb(255, 255, 0)`;
                    // Adjust score text font size based on device type
                    this.ctx.font = `bold ${this.deviceType === 'mobile' ? '12px' : '16px'} Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(st.text, st.x, st.y);
                });
                this.ctx.restore();

                // Wave indicator
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                // Adjust wave indicator font size and position based on device type
                this.ctx.font = `${this.deviceType === 'mobile' ? '16px' : '20px'} Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`Wave ${this.wave}`, canvasWidth / 2, this.deviceType === 'mobile' ? 40 : 50);
            }
        }

        class Player {
            constructor(x, y) {
                this.radius = 25;
                this.speed = 350;
                this.maxHealth = 100;
                this.fireRate = 200;
                this.damage = 25;
                this.spawn(x,y);
                this.powerUps = {};
            }

            spawn(x, y) {
                this.x = x;
                this.y = y;
                this.health = this.maxHealth;
                this.lastFire = 0;
                this.isInvincible = true;
                this.invincibleTimer = 3000;
            }

            update(deltaTime, canvasWidth, playAreaTop, playAreaBottom) {
                if (this.isInvincible) {
                    this.invincibleTimer -= deltaTime;
                    if (this.invincibleTimer <= 0) {
                        this.isInvincible = false;
                    }
                }
                Object.keys(this.powerUps).forEach(key => {
                    this.powerUps[key] -= deltaTime;
                    if (this.powerUps[key] <= 0) delete this.powerUps[key];
                });

                // Enforce strict boundaries within the safe play area
                this.x = Math.max(this.radius, Math.min(this.x, canvasWidth - this.radius));
                this.y = Math.max(playAreaTop + this.radius, Math.min(this.y, playAreaBottom - this.radius));
            }

            move(dx, dy, deltaTime) {
                const currentSpeed = this.speed * (this.powerUps.speedBoost ? 1.5 : 1);
                const moveSpeed = currentSpeed * deltaTime / 1000;
                const mag = Math.sqrt(dx*dx + dy*dy) || 1;
                this.x += (dx / mag) * moveSpeed;
                this.y += (dy / mag) * moveSpeed;
            }

            moveTowards(targetX, targetY, deltaTime) {
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 5) {
                    const currentSpeed = this.speed * (this.powerUps.speedBoost ? 1.5 : 1);
                    const moveSpeed = currentSpeed * deltaTime / 1000;
                    this.x += (dx / dist) * moveSpeed;
                    this.y += (dy / dist) * moveSpeed;
                }
            }

            canFire() { return Date.now() - this.lastFire > this.fireRate; }

            fire() {
                this.lastFire = Date.now();
                const projectiles = [];
                const damage = this.damage * (this.powerUps.damageBoost ? 1.5 : 1);
                
                if (this.powerUps.multiShot) {
                    projectiles.push(new Projectile(this.x - 10, this.y - 20, 0, -500, damage, true), new Projectile(this.x, this.y - 20, 0, -500, damage, true), new Projectile(this.x + 10, this.y - 20, 0, -500, damage, true));
                } else if (this.powerUps.spreadShot) {
                    projectiles.push(new Projectile(this.x, this.y - 20, -100, -500, damage, true), new Projectile(this.x, this.y - 20, 0, -500, damage, true), new Projectile(this.x, this.y - 20, 100, -500, damage, true));
                } else {
                    projectiles.push(new Projectile(this.x, this.y - 20, 0, -500, damage, true));
                }
                return projectiles;
            }

            takeDamage(damage) {
                if (this.isInvincible) return false;
                if (this.powerUps.shield) {
                    delete this.powerUps.shield;
                    return false;
                }
                this.health -= damage;
                return this.health <= 0;
            }

            applyPowerUp(type) { 
                this.powerUps[type] = 10000;
                if (type === 'shield') {
                    this.powerUps[type] = 15000;
                }
            }

            render(ctx) {
                if (this.isInvincible && Math.floor(Date.now() / 100) % 2 === 0) return;
                
                // Shield effect
                if (this.powerUps.shield) {
                    const time = Date.now() / 1000;
                    const shieldOpacity = 0.5 + Math.sin(time * 5) * 0.3;
                    ctx.strokeStyle = `rgba(0, 150, 255, ${shieldOpacity})`;
                    ctx.fillStyle = `rgba(0, 150, 255, ${shieldOpacity * 0.2})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 15, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fill();
                }

                // Realistic rocket body
                ctx.save();
                
                // Main body (metallic silver)
                const gradient = ctx.createLinearGradient(this.x - this.radius, this.y, this.x + this.radius, this.y);
                gradient.addColorStop(0, '#c0c0c0');
                gradient.addColorStop(0.5, '#ffffff');
                gradient.addColorStop(1, '#808080');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.radius * 0.6, this.radius, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Nose cone (darker metal)
                ctx.fillStyle = '#606060';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - this.radius);
                ctx.lineTo(this.x - this.radius * 0.4, this.y - this.radius * 0.4);
                ctx.lineTo(this.x + this.radius * 0.4, this.y - this.radius * 0.4);
                ctx.closePath();
                ctx.fill();
                
                // Wings/fins
                ctx.fillStyle = '#4a4a4a';
                ctx.beginPath();
                ctx.moveTo(this.x - this.radius * 0.6, this.y + this.radius * 0.3);
                ctx.lineTo(this.x - this.radius * 1.2, this.y + this.radius * 0.8);
                ctx.lineTo(this.x - this.radius * 0.3, this.y + this.radius * 0.6);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(this.x + this.radius * 0.6, this.y + this.radius * 0.3);
                ctx.lineTo(this.x + this.radius * 1.2, this.y + this.radius * 0.8);
                ctx.lineTo(this.x + this.radius * 0.3, this.y + this.radius * 0.6);
                ctx.closePath();
                ctx.fill();
                
                // Engine flames
                const flameHeight = this.radius * 1.2 + Math.random() * 5;
                const flameWidth = this.radius * 0.8;
                
                // Outer flame (orange)
                ctx.fillStyle = '#ff6b35';
                ctx.beginPath();
                ctx.moveTo(this.x - flameWidth/2, this.y + this.radius * 0.8);
                ctx.lineTo(this.x + flameWidth/2, this.y + this.radius * 0.8);
                ctx.lineTo(this.x, this.y + this.radius * 0.8 + flameHeight);
                ctx.closePath();
                ctx.fill();
                
                // Inner flame (blue-white)
                ctx.fillStyle = '#00bfff';
                ctx.beginPath();
                ctx.moveTo(this.x - flameWidth/4, this.y + this.radius * 0.8);
                ctx.lineTo(this.x + flameWidth/4, this.y + this.radius * 0.8);
                ctx.lineTo(this.x, this.y + this.radius * 0.8 + flameHeight * 0.7);
                ctx.closePath();
                ctx.fill();
                
                // Window/cockpit
                ctx.fillStyle = 'rgba(100, 150, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(this.x, this.y - this.radius * 0.2, this.radius * 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();

                // Health bar
                const barW = 40, barH = 4, barX = this.x - barW / 2, barY = this.y - this.radius - 20;
                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.fillRect(barX, barY, barW, barH);
                ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                ctx.fillRect(barX, barY, barW * (this.health / this.maxHealth), barH);
            }
        }

        class Projectile {
            constructor(x, y, vx, vy, damage, isPlayerProjectile = false) {
                this.x = x; this.y = y; this.vx = vx; this.vy = vy;
                this.damage = damage; this.isPlayerProjectile = isPlayerProjectile;
                this.radius = 4;
            }
            update(deltaTime) {
                const factor = deltaTime / 1000;
                this.x += this.vx * factor;
                this.y += this.vy * factor;
                return true;
            }
            render(ctx) {
                ctx.fillStyle = this.isPlayerProjectile ? '#00ff88' : '#ff4757';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Glow effect
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.isPlayerProjectile ? '#00ff88' : '#ff4757';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class Enemy {
            constructor(x, y, health, points) {
                this.x = x; this.y = y; this.health = health; this.maxHealth = health;
                this.points = points; this.damage = 25; this.radius = 15;
                this.speed = 150; 
                this.fireRate = 700; // Reduced fire rate from 1000 to 700
                this.lastFire = Date.now();
            }
            update(deltaTime) { 
                this.y += this.speed * deltaTime / 1000; 
            }
            canFire() { return Date.now() - this.lastFire > this.fireRate; }
            fire() {
                this.lastFire = Date.now();
                return [new Projectile(this.x, this.y + this.radius, 0, 300, this.damage, false)];
            }
            render(ctx) {
                if (this.health < this.maxHealth) {
                    const barW = 30, barH = 3, barX = this.x - barW / 2, barY = this.y - this.radius - 10;
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.7)'; ctx.fillRect(barX, barY, barW, barH);
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.7)'; ctx.fillRect(barX, barY, barW * (this.health / this.maxHealth), barH);
                }
            }
        }

        class Meteor extends Enemy {
            constructor(x, y) {
                super(x, y, 50, 50);
                this.radius = 20 + Math.random() * 10;
                this.speed = 100 + Math.random() * 100;
                this.rotation = 0;
                this.rotationSpeed = Math.random() * 2 - 1;
            }
            canFire() { return false; }
            update(deltaTime) {
                super.update(deltaTime);
                this.rotation += this.rotationSpeed * deltaTime / 1000;
            }
            render(ctx) {
                super.render(ctx);
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = '#8B4513'; ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#A0522D'; ctx.beginPath(); ctx.arc(-5, -5, this.radius * 0.4, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(7, 3, this.radius * 0.2, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }
        }

        class AlienShip extends Enemy {
            constructor(x, y) {
                super(x, y, 75, 100);
                this.radius = 18;
                this.speed = 120;
                this.fireRate = 900; // Reduced fire rate from 1200 to 900
                this.zigzag = Math.random() * Math.PI * 2;
            }
            update(deltaTime) {
                super.update(deltaTime);
                this.zigzag += deltaTime / 1000 * 2;
                this.x += Math.sin(this.zigzag) * 60 * deltaTime / 1000;
            }
            render(ctx) {
                super.render(ctx);
                ctx.save();
                
                // Main saucer body - Realistic metallic design
                const gradient = ctx.createRadialGradient(this.x, this.y, this.radius * 0.2, this.x, this.y, this.radius);
                gradient.addColorStop(0, '#a8a8a8');
                gradient.addColorStop(0.3, '#7f8c8d');
                gradient.addColorStop(0.7, '#5a6c75');
                gradient.addColorStop(1, '#34495e');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.radius, this.radius * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Metallic rim
                ctx.strokeStyle = '#95a5a6';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.radius, this.radius * 0.7, 0, 0, Math.PI * 2);
                ctx.stroke();
                
                // Cockpit dome
                const cockpitGradient = ctx.createRadialGradient(this.x, this.y - 2, 1, this.x, this.y, this.radius * 0.6);
                cockpitGradient.addColorStop(0, '#85c1e9');
                cockpitGradient.addColorStop(0.5, '#5dade2');
                cockpitGradient.addColorStop(1, '#2e86ab');
                ctx.fillStyle = cockpitGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y - 2, this.radius * 0.6, 0, Math.PI, true);
                ctx.fill();
                
                // Engine ports
                ctx.fillStyle = '#e74c3c';
                for (let i = 0; i < 4; i++) {
                    const angle = (Math.PI / 2) * i;
                    const portX = this.x + Math.cos(angle) * this.radius * 0.8;
                    const portY = this.y + Math.sin(angle) * this.radius * 0.6;
                    ctx.beginPath();
                    ctx.arc(portX, portY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        class Boss extends Enemy {
            constructor(x, y) {
                super(x, y, 500, 1000);
                this.radius = 40; this.speed = 80; this.fireRate = 400;
                this.phase = 0; this.phaseTimer = 0;
            }
            update(deltaTime) {
                super.update(deltaTime);
                this.phaseTimer += deltaTime;
                if (this.phaseTimer > 5000) { this.phase = (this.phase + 1) % 3; this.phaseTimer = 0; }
                if (this.phase === 0) this.x += Math.sin(Date.now() / 1000) * 100 * deltaTime / 1000;
                else if (this.phase === 1) this.x += Math.cos(Date.now() / 1000) * 80 * deltaTime / 1000;
                else this.speed = 150;
            }
            fire() {
                this.lastFire = Date.now();
                const projectiles = [];
                if (this.phase === 2) {
                    for (let i = 0; i < 3; i++) {
                        projectiles.push(new Projectile(this.x, this.y + this.radius, (Math.random() - 0.5) * 400, 300, this.damage, false));
                    }
                } else {
                    for (let i = 0; i < 5; i++) {
                        const angle = (Math.PI / 4) * (i - 2);
                        const vx = Math.sin(angle) * 200, vy = Math.cos(angle) * 200;
                        projectiles.push(new Projectile(this.x, this.y + this.radius, vx, vy, this.damage, false));
                    }
                }
                return projectiles;
            }
            render(ctx) {
                super.render(ctx);
                ctx.save();
                
                // Main hull - Advanced battleship design
                const hullGradient = ctx.createLinearGradient(this.x - this.radius, this.y, this.x + this.radius, this.y);
                hullGradient.addColorStop(0, '#6c7b7f');
                hullGradient.addColorStop(0.3, '#95a5a6');
                hullGradient.addColorStop(0.5, '#bdc3c7');
                hullGradient.addColorStop(0.7, '#95a5a6');
                hullGradient.addColorStop(1, '#5d6d70');
                ctx.fillStyle = hullGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Armored plating
                ctx.strokeStyle = '#7f8c8d';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Central weapon system
                const weaponGradient = ctx.createRadialGradient(this.x, this.y, 2, this.x, this.y, this.radius * 0.5);
                weaponGradient.addColorStop(0, '#ff6b81');
                weaponGradient.addColorStop(0.5, '#e55572');
                weaponGradient.addColorStop(1, '#c0392b');
                ctx.fillStyle = weaponGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Side weapon pods
                const podRadius = this.radius * 0.3;
                for (let i = -1; i <= 1; i += 2) {
                    const podX = this.x + (this.radius * 0.9) * i;
                    const podY = this.y + this.radius * 0.2;
                    
                    // Pod body
                    ctx.fillStyle = '#5a6c75';
                    ctx.beginPath();
                    ctx.arc(podX, podY, podRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Pod weapon
                    ctx.fillStyle = '#e74c3c';
                    ctx.beginPath();
                    ctx.arc(podX, podY, podRadius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        class PowerUp {
            constructor(x, y) {
                this.x = x; this.y = y; this.radius = 12; this.speed = 100;
                this.type = ['multiShot', 'spreadShot', 'shield', 'speedBoost', 'damageBoost'][Math.floor(Math.random() * 5)];
                this.pulse = 0;
            }
            update(deltaTime) { this.y += this.speed * deltaTime / 1000; this.pulse += deltaTime / 1000 * 5; return true; }
            render(ctx) {
                const pulseSize = Math.sin(this.pulse) * 3;
                ctx.fillStyle = this.getColor(); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius + pulseSize, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = 'white'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center';
                ctx.fillText(this.getSymbol(), this.x, this.y + 4);
            }
            getColor() {
                switch (this.type) {
                    case 'multiShot': return '#00ff88'; case 'spreadShot': return '#ff9f43';
                    case 'shield': return '#0abde3'; case 'speedBoost': return '#ee5a6f';
                    case 'damageBoost': return '#e056fd';
                    default: return '#ffffff';
                }
            }
            getSymbol() {
                switch (this.type) {
                    case 'multiShot': return '|||'; case 'spreadShot': return '><';
                    case 'shield': return 'â—Š'; case 'speedBoost': return 'Â»';
                    case 'damageBoost': return 'âš¡';
                    default: return '?';
                }
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; 
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 150 + 50;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.color = color;
                this.size = Math.random() * 4 + 2; this.life = 1;
                this.decay = Math.random() * 0.02 + 0.01;
            }
            update(deltaTime) {
                const factor = deltaTime / 1000;
                this.x += this.vx * factor; this.y += this.vy * factor;
                this.life -= this.decay; this.size *= 0.98;
                return this.life > 0;
            }
            render(ctx) {
                ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
    </script>
</body>
</html>
